#!/bin/bash
# ╭──────────────────────────────────────────────────────────────────────────────╮
# │                                                                              │
# │                                  VUMP SITE                                   │
# │                            Web files and Database                            │
# │                                                                              │
# ╰──────────────────────────────────────────────────────────────────────────────╯



# Deine all spinnaker icons / colours
function stylesheet()
{
    TEXT_WHITE_FFF='\e[38;2;255;255;255m'
    TEXT_STONE_500='\e[38;2;120;113;108m'
    TEXT_STONE_600='\e[38;2;87;83;78m'
    TEXT_ORANGE_500='\e[38;2;249;115;22m'
    TEXT_YELLOW_500='\e[38;2;234;179;8m'
    TEXT_GRAY_200='\e[38;2;229;231;235m'
    TEXT_GRAY_400='\e[38;2;156;163;175m'
    TEXT_GRAY_500='\e[38;2;107;114;128m'
    TEXT_GRAY_600='\e[38;2;75;85;99m'
    TEXT_GRAY_700='\e[38;2;55;65;81m'
    TEXT_VIOLET_500='\e[38;2;139;92;246m'
    TEXT_RED_500='\e[38;2;239;68;68m'
    TEXT_GREEN_500='\e[38;2;34;197;94m'
    TEXT_EMERALD_500='\e[38;2;16;185;129m'
    TEXT_TEAL_500='\e[38;2;20;184;166m'
    TEXT_SKY_500='\e[38;2;14;165;233m'
    TEXT_AMBER_500='\e[38;2;245;158;11m'
    RESET_TEXT='\e[39m'
    RESET_ALL='\e[0m\e[39m\e[49m\033[0m\033[K'
    ICON_FADE_200=░
    ICON_CMD=⌘
    ICON_ARROW_N=↑
    ICON_ARROW_S=↓
    ICON_ARROW_E=→
    ICON_ARROW_W=←
    ICON_CIRCLE=●
    ICON_TICK=✅
    ICON_CROSS=❌
    BORDER_SKY_400='\e[38;2;56;189;248m'
    BORDER_EMERALD_400='\e[38;2;52;211;153m'
    BORDER_PINK_400='\e[38;2;244;114;182m'
    BORDER_ROSE_400='\e[38;2;251;113;133m'
    BORDER_FUCHSIA_400='\e[38;2;232;121;249m'
    BORDER_PURPLE_400='\e[38;2;192;132;252m'
    BORDER_INDIGO_400='\e[38;2;129;140;248m'
    BORDER_BLUE_400='\e[38;2;96;165;250m'
    BORDER_CYAN_400='\e[38;2;34;211;238m'
    BORDER_TEAL_400='\e[38;2;45;212;191m'
    BORDER_GREEN_400='\e[38;2;74;222;128m'
    BORDER_YELLOW_400='\e[38;2;250;204;21m'
    BORDER_ORANGE_400='\e[38;2;251;146;60m'
    BORDER_RED_400='\e[38;2;248;113;113m'
}

# ╭──────────────────────────────────────────────────────────╮
# │                                                          │
# │                      Read .env file                      │
# │                                                          │
# ╰──────────────────────────────────────────────────────────╯
set -o allexport
source .env 
set +o allexport


# ╭──────────────────────────────────────────────────────────╮
# │                        UTILITIES                         │
# ╰──────────────────────────────────────────────────────────╯

function tar_zip_folder()
{
    tar -cvzf ${VUMP_FILE_EXPORT_NAME} ./vump_backup
}


# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                              ║
# ║                              REGISTRY FUNCTIONS                              ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝


# ╭──────────────────────────────────────────────────────────╮
# │       Push the new image to the container registry       │
# ╰──────────────────────────────────────────────────────────╯
function push_to_registry()
{
    clear
    IMAGE_NAME="$IMAGE_NAME"
    IMAGE_ID=$(docker image ls -q --filter reference=${IMAGE_NAME})

    printf "${TEXT_RED_500} (you must be logged in with 'docker login' or 'az login acr')${RESET_TEXT}\n\n"

    printf "The image $IMAGE_NAME:latest will be pushed to the following locations:\n"
    printf "${ICON_CIRCLE} ${TEXT_GREEN_500}$REGISTRY_REPO:latest ${RESET_TEXT} \n"
    printf "${ICON_CIRCLE} ${TEXT_GREEN_500}$REGISTRY_REPO:$IMAGE_ID ${RESET_TEXT} \n\n"
    confirmation "Do you want to push image to container registry?"

    printf "\n"

    # ╭──────────────────────────────────────────────────────────╮
    # │                    PUSH WITH :HASH_ID                    │
    # ╰──────────────────────────────────────────────────────────╯
    # Tag :IMAGE_ID
    echo "tag  ${IMAGE_NAME}:latest ${VUMP_REGISTRY_REPO}:${IMAGE_ID}"
    if ! docker image tag ${IMAGE_NAME}:latest ${VUMP_REGISTRY_REPO}:${IMAGE_ID};
    then
        printf "\n${TEXT_RED_500}Error: Failed to tag image with image ID.\n"
        exit 1
    fi

    # Push :IMAGE_ID
    PUSH_TAG="${IMAGE_ID}"
    spin "docker_push_to_registry" "pushing :${IMAGE_ID} to registry" "push to registry"

    # Delete from local images
    if ! docker image rm ${VUMP_REGISTRY_REPO}:${IMAGE_ID};
    then
        printf "\n${TEXT_RED_500}Error: Failed to remove ${VUMP_REGISTRY_REPO}:${IMAGE_ID}.\n"
        exit 1
    fi


    # ╭──────────────────────────────────────────────────────────╮
    # │                     PUSH WITH :LATEST                    │
    # ╰──────────────────────────────────────────────────────────╯

    # Tag :Latest
    if ! docker image tag ${IMAGE_NAME}:latest ${VUMP_REGISTRY_REPO}:latest;
    then
        printf "\n${TEXT_RED_500}Error: Failed to tag image ${IMAGE_NAME}:latest as ${VUMP_REGISTRY_REPO}:latest.\n"
        exit 1
    fi

    # Push :Latest
    PUSH_TAG="latest"
    spin "docker_push_to_registry" "pushing :latest to registry" "push to registry"

    # Delete from local images
    if ! docker image rm ${VUMP_REGISTRY_REPO}:latest;
    then
        printf "\n${TEXT_RED_500}Error: Failed to remove ${VUMP_REGISTRY_REPO}:latest.\n"
        exit 1
    fi

}


# Push to the registry.
function docker_push_to_registry()
{
    printf "running ${TEXT_EMERALD_500}docker push ${VUMP_REGISTRY_REPO}:${VUMP_PULL_TAG}${RESET_TEXT} to container registry.\n"

    if ! docker push ${VUMP_REGISTRY_REPO}:${PUSH_TAG};
    then
        printf "\n${TEXT_RED_500}Error: Failed to push ${VUMP_REGISTRY_REPO}:${PUSH_TAG} to container registry.\n"
        exit 1
    fi
}





# ╭──────────────────────────────────────────────────────────────────────────────╮
# │                              PULL FROM REGISTRY                              │
# ╰──────────────────────────────────────────────────────────────────────────────╯

function pull_from_registry()
{
    printf "${TEXT_RED_500} (you must be logged in with 'docker login' or 'az login acr')${RESET_TEXT}\n\n"

    spin "docker_pull_from_registry" "importing" "Pull from registry"
}

# Pull from registry
function docker_pull_from_registry()
{

    printf "running ${TEXT_EMERALD_500}docker pull ${VUMP_REGISTRY_REPO}:${VUMP_PULL_TAG}${RESET_TEXT} from container registry.\n"

    if ! docker pull ${VUMP_REGISTRY_REPO}:${VUMP_PULL_TAG};
    then
        printf "\n${TEXT_RED_500}Error: Failed to pull ${VUMP_REGISTRY_REPO}:${VUMP_PULL_TAG} from container registry.\n\n"
        exit 1
    fi
}


# ╭──────────────────────────────────────────────────────────╮
# │          Select a docker container from a list           │
# ╰──────────────────────────────────────────────────────────╯
function select_container()
{
    
    QUESTION="$1"

    LIST_OF_CONTAINERS=$(docker container ls -a --format='{{.ID}} {{.Names}} {{.Image}}')

    MENU='
        {
        "select": {
            "heading": "'${BORDER_YELLOW_400}${QUESTION}'",
            "clear": true,
            "clear_before_command": true,
            "icon": "ICON_FADE_200",
            "hide_message": true,
            "display_help": true,
            "reset_loop": false,
            "previous_step": "mainmenu",
            "options": ['

    LOOP=1
    while IFS= read -r line; do

        CONTAINER_ID=$(echo $line | head -n1 | cut -d " " -f1 | xargs )
        CONTAINER_NAME=$(echo $line | head -n1 | cut -d " " -f2 | xargs )
        CONTAINER_IMAGE=$(echo $line | head -n1 | cut -d " " -f3 | xargs )

        MENU+='
                {
                    "title": "'${CONTAINER_NAME}'",
                    "title_style": "",
                    "description": "'${TEXT_GRAY_700}${CONTAINER_ID}' '${TEXT_GRAY_600}${CONTAINER_NAME}'",
                    "description_style": "TEXT_GRAY_500",
                    "command": "CONTAINER=\"'${CONTAINER_NAME}'\" ",
                    "bullet": "BORDER_FUCHSIA_400"
                },'

        LOOP=$(( LOOP+1 ))
    done <<< "$LIST_OF_CONTAINERS"

    MENU+='
            ]
        }
    }'
    
    menu "$MENU"
}

# ╭──────────────────────────────────────────────────────────╮
# │             Select a docker volume from list             │
# ╰──────────────────────────────────────────────────────────╯
function select_volume()
{

    QUESTION="$1"

    LIST_OF_VOLUMES=$(docker volume ls --format='{{lower .Name}} {{lower .Mountpoint}}')

    MENU='
        {
        "select": {
            "heading": "'${BORDER_YELLOW_400}${QUESTION}'.",
            "clear": true,
            "clear_before_command": true,
            "icon": "ICON_FADE_200",
            "hide_message": true,
            "display_help": true,
            "reset_loop": false,
            "previous_step": "mainmenu",
            "options": ['

    LOOP=1
    while IFS= read -r line; do

        VOLUME_NAME=$(echo $line | head -n1 | cut -d " " -f1 | xargs )
        VOLUME_MOUNTPOINT=$(echo $line | head -n1 | cut -d " " -f2 | xargs )

        MENU+='
                {
                    "title": "'${VOLUME_NAME}'",
                    "title_style": "",
                    "description": "Mountpoint: '${VOLUME_MOUNTPOINT}'",
                    "description_style": "TEXT_GRAY_500",
                    "command": "VOLUME=\"'${VOLUME_NAME}'\" ",
                    "bullet": "BORDER_SKY_400"
                },'

        LOOP=$(( LOOP+1 ))
    done <<< "$LIST_OF_VOLUMES"

    MENU+='
            ]
        }
    }'
    
    menu "$MENU"

}


# ╭──────────────────────────────────────────────────────────╮
# │              Select a docker image for list              │
# ╰──────────────────────────────────────────────────────────╯
function select_image()
{

    QUESTION="$1"

    LIST_OF_IMAGES=$(docker image ls --format='{{lower .ID}} {{lower .Repository}} {{lower .Size}} {{lower .Tag}}')

    MENU='
        {
        "select": {
            "heading": "'${BORDER_YELLOW_400}${QUESTION}'",
            "clear": true,
            "clear_before_command": true,
            "icon": "ICON_FADE_200",
            "hide_message": true,
            "display_help": true,
            "reset_loop": false,
            "previous_step": "mainmenu",
            "options": ['

    LOOP=1
    while IFS= read -r line; do

        IMAGE_ID=$(echo $line | head -n1 | cut -d " " -f1 | xargs )
        IMAGE_REPOSITORY=$(echo $line | head -n1 | cut -d " " -f2 | xargs )
        IMAGE_SIZE=$(echo $line | head -n1 | cut -d " " -f3 | xargs )
        IMAGE_TAG=$(echo $line | head -n1 | cut -d " " -f4 | xargs )

        MENU+='
                {
                    "title": "'${IMAGE_REPOSITORY}'",
                    "title_style": "",
                    "description": "ID: '${TEXT_GRAY_500}${IMAGE_ID}${TEXT_GRAY_700}' TAG: '${TEXT_GRAY_500}${IMAGE_TAG}${TEXT_GRAY_700}' SIZE: '${TEXT_GRAY_500}${IMAGE_SIZE}${TEXT_GRAY_700}'",
                    "description_style": "TEXT_GRAY_700",
                    "command": "IMAGE=\"'${IMAGE_ID}'\" ",
                    "bullet": "TEXT_GREEN_500"
                },'

        LOOP=$(( LOOP+1 ))
    done <<< "$LIST_OF_IMAGES"

    MENU+='
            ]
        }
    }'
    
    menu "$MENU"
}


# ╭──────────────────────────────────────────────────────────╮
# │           Select a docker database from a list           │
# ╰──────────────────────────────────────────────────────────╯
function select_database()
{
    QUESTION="$1"

    LIST_OF_DATABASES=$(docker exec $VUMP_DATABASE_CONTAINER_NAME mysql -u$VUMP_DB_USERNAME -p$VUMP_DB_PASSWORD --silent --execute="show databases;" )

    MENU='
        {
        "select": {
            "heading": "'${BORDER_YELLOW_400}${QUESTION}'.",
            "clear": true,
            "clear_before_command": true,
            "icon": "ICON_FADE_200",
            "hide_message": true,
            "display_help": true,
            "reset_loop": false,
            "previous_step": "mainmenu",
            "options": ['

    LOOP=1
    while IFS= read -r line; do

        MENU+='
                {
                    "title": "'${line}'",
                    "title_style": "",
                    "description": "Option '${LOOP}'",
                    "description_style": "TEXT_GRAY_500",
                    "command": "DB_DATABASE=\"'${line}'\" ",
                    "bullet": "BORDER_TEAL_400"
                },'

        LOOP=$(( LOOP+1 ))
    done <<< "$LIST_OF_DATABASES"

    MENU+='
            ]
        }
    }'
    
    menu "$MENU"
}


# ╭──────────────────────────────────────────────────────────╮
# │                      Ask a question                      │
# ╰──────────────────────────────────────────────────────────╯
function ask_question()
{

    QUESTION=$1

    printf "${BORDER_YELLOW_400}%s${RESET_TEXT}\n\n " "$QUESTION"

    printf "${TEXT_SKY_500}"
    read -p "${ICON_FADE_200} " ANSWER
    printf "${RESET_TEXT}\n"
}



# ╭──────────────────────────────────────────────────────────╮
# │                  Check Y/n to continue                   │
# ╰──────────────────────────────────────────────────────────╯
function confirmation()
{
    QUESTION=$1
    printf "${TEXT_AMBER_500} %s ${RESET_TEXT}\n" "$QUESTION"
    read -r -p "Are you sure? [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY]) 
            CONFIRM="YES"
            ;;
        *)
            CONFIRM=""
            exit
            ;;
    esac
}

# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                              ║
# ║                             START - JSON MENU CODE                           ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝


function getkey {
    KEYSTRING=$(sed -e 's/\[/\"\,/g' -e 's/^\"\,/\[/g' -e 's/\]\./\,\"/g' -e 's/\./\"\,\"/g' -e '/^\[/! s/^/\[\"/g' -e '/\]$/! s/$/\"\]/g' <<< "$@")
    FOUT=$(grep -F "$KEYSTRING" <<< "$JSON_PARSED")
    FOUT="${FOUT#*$'\t'}"
    FOUT="${FOUT#*\"}"
    FOUT="${FOUT%\"*}"
    echo "$FOUT"
}

function getarrlen {
    KEYSTRING=$(sed -e '/^\[/! s/\[/\"\,/g' -e 's/\]\./\,\"/g' -e 's/\./\"\,\"/g' -e '#^$#! {/^\[/! s/^/\[\"/g}' -e '/^$/! s/$/\"\,/g' -e 's/\[/\\\[/g' -e 's/\]/\\\]/g' -e 's/\,/\\\,/g' -e '/^$/ s/^/\\\[/g' <<< "$@")
    LEN=$(grep -o "${KEYSTRING}[0-9]*" <<< "$JSON_PARSED" | tail -n -1 | grep -o "[0-9]*$")
    if [ -n "$LEN" ]; then
        LEN=$(($LEN+1))
    else
        LEN="0"
    fi
    echo "$LEN"
}


function parse_classes()
{
    PREFIX=$1

    CLASSES=$2
    export IFS=" "
    for CLASS in $CLASSES; do

        IFS="_" read PARAMETER PRIMARY SECONDARY <<< "$CLASS"

        if  [[ $PARAMETER == 'TEXT' ]] || 
            [[ $PARAMETER == 'BG' ]] || 
            [[ $PARAMETER == 'BORDER' ]]; then
            export declare "${PREFIX}_${PARAMETER}_COLOUR"=${!CLASS}
        fi
        if  [[ $PARAMETER == PX* ]] || 
            [[ $PARAMETER == PY* ]] || 
            [[ $PARAMETER == PT* ]] || 
            [[ $PARAMETER == PR* ]] || 
            [[ $PARAMETER == PB* ]] || 
            [[ $PARAMETER == PL* ]]; then

            export declare "${PREFIX}_$PARAMETER"=${!CLASS}
        fi 
        if  [[ $PARAMETER == EDGE* ]] && [[ $SECONDARY == "" ]] ; then
            VAR="${PARAMETER}_${PRIMARY}_TL"; export declare "${PREFIX}_${PARAMETER}_TL"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_T";  export declare "${PREFIX}_${PARAMETER}_T"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_TR"; export declare "${PREFIX}_${PARAMETER}_TR"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_R";  export declare "${PREFIX}_${PARAMETER}_R"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_BR"; export declare "${PREFIX}_${PARAMETER}_BR"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_B";  export declare "${PREFIX}_${PARAMETER}_B"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_BL"; export declare "${PREFIX}_${PARAMETER}_BL"=${!VAR}
            VAR="${PARAMETER}_${PRIMARY}_L";  export declare "${PREFIX}_${PARAMETER}_L"=${!VAR}
        fi 
        if [[ $PARAMETER == EDGE* ]] && ! [[ $SECONDARY == "" ]] ; then
            VAR="${CLASS}"; export declare "${PREFIX}_${PARAMETER}_${SECONDARY}"=${!VAR}
        fi
        if  [[ $PARAMETER == 'W' ]]; then
            export declare "${PREFIX}_${PARAMETER}"=${!CLASS}
        fi    
        
        if  [[ $PARAMETER == 'H' ]]; then
            export declare "${PREFIX}_${PARAMETER}"=${!CLASS}
        fi
        if  [[ $PARAMETER == 'ALIGN' ]]; then
            export declare "${PREFIX}_${PARAMETER}"=${!CLASS}
        fi

    done
}


function select_option {
    
    HEIGHT=3
    FOOTER_HEIGHT=2

    ESC=$( printf "\033")                                                               
    cursor_blink_on()  { printf "$ESC[?25h"; }                                          
    cursor_blink_off() { printf "$ESC[?25l"; }                                          
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }                                   
    
    ref_to_content()   {
        VARNAME=$1
        REFERENCE=${!VARNAME}
        echo "${REFERENCE}"
    }

    ref_to_ref_to_content()   {
        VARNAME=$1
        REFERENCE=${!VARNAME}
        OUTPUTNEW=${!REFERENCE}
        echo "${OUTPUTNEW}"
    }

    print_option()     {                                                                
        TEXT=$1
        LOOP_INDEX=$2

        TITLE=$( ref_to_content "SELECT_ARRAY_TITLE_${LOOP_INDEX}" )
        TITLE_STYLE=$(ref_to_ref_to_content "SELECT_ARRAY_TITLE_STYLE_${LOOP_INDEX}")
        DESCRIPTION=$(ref_to_content "SELECT_ARRAY_DESCRIPTION_${LOOP_INDEX}")
        DESCRIPTION_STYLE=$(ref_to_ref_to_content "SELECT_ARRAY_DESCRIPTION_STYLE_${LOOP_INDEX}")

        TITLE=$(eval "printf \"${TITLE}\"")
        DESCRIPTION=$(eval "printf \"${DESCRIPTION}\"")

        OPTION_TEXT=''
        OPTION_TEXT+="  "
        OPTION_TEXT+="${TITLE_STYLE}"
        OPTION_TEXT+="${TITLE}\n"
        OPTION_TEXT+="${RESET_TEXT}"
        OPTION_TEXT+="  "
        OPTION_TEXT+="${DESCRIPTION_STYLE}"
        OPTION_TEXT+="${DESCRIPTION}"
        OPTION_TEXT+="${RESET_ALL}"

        printf "$OPTION_TEXT"; 
    }               

    invert_selected()  {                                                                
        TEXT=$1
        LOOP_INDEX=$2

        TITLE=$( ref_to_content "SELECT_ARRAY_TITLE_${LOOP_INDEX}" )
        TITLE_STYLE=$(ref_to_ref_to_content "SELECT_ARRAY_TITLE_STYLE_${LOOP_INDEX}")
        DESCRIPTION=$(ref_to_content "SELECT_ARRAY_DESCRIPTION_${LOOP_INDEX}")
        DESCRIPTION_STYLE=$(ref_to_ref_to_content "SELECT_ARRAY_DESCRIPTION_STYLE_${LOOP_INDEX}")
        SIDEBAR_STYLE=$(ref_to_ref_to_content "SELECT_ARRAY_SIDEBAR_STYLE_${LOOP_INDEX}")
        SIDEBAR_ICON=$(ref_to_content "$SELECT_ARRAY_SIDEBAR_ICON")

        TITLE=$(eval "printf \"${TITLE}\"")
        DESCRIPTION=$(eval "printf \"${DESCRIPTION}\"")

        OPTION_TEXT=''
        OPTION_TEXT+="${SIDEBAR_STYLE}"
        OPTION_TEXT+="${SIDEBAR_ICON} "
        OPTION_TEXT+="${TITLE_STYLE}"
        OPTION_TEXT+="${TITLE}\n"
        OPTION_TEXT+="${RESET_TEXT}"
        OPTION_TEXT+="${SIDEBAR_STYLE}"
        OPTION_TEXT+="${SIDEBAR_ICON} "
        OPTION_TEXT+="${DESCRIPTION_STYLE}"
        OPTION_TEXT+="${DESCRIPTION}"
        OPTION_TEXT+="${RESET_ALL}"

        printf "$OPTION_TEXT"; 

    }                                  

    get_terminal_height()   {                                                           
        IFS=';'                                                                         
        read -sdR -p $'\E[6n' ROW COL;                                                  
        echo ${ROW#*[};                                                                 
    }             

    key_input()        
    { 
        read -s -n3 key 2>/dev/null >&2  
        if [[ $key = $ESC[A ]]; then echo up;    fi                 
        if [[ $key = $ESC[B ]]; then echo down;  fi    
        if [[ $key = $ESC[C ]]; then echo right;    fi                 
        if [[ $key = $ESC[D ]]; then echo left;  fi              
        if [[ $key = ""     ]]; then echo enter; fi; 
    }              

    NEWLINE_COUNT=$(( $# * $HEIGHT ))
    for (( c=1; c<=$NEWLINE_COUNT; c++)) ; do 
        printf "\n" ; 
    done

    local lastrow=$(get_terminal_height)                                               
    TOTAL_LINES=$(( $# * $HEIGHT ))                                                     
    local STARTING_ROW=$(( $lastrow - $TOTAL_LINES ))                                  
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2                              
    cursor_blink_off                                                                    

    local selected=0                                                                    
    while true; do                                                                     

            local LINE_OFFSET=0                                                               

            for opt; do                                                                       

                cursor_to $(( $STARTING_ROW + $LINE_OFFSET )) 0                               

                if [ $LINE_OFFSET -eq $(( $selected * $HEIGHT)) ]; then                       
                    invert_selected "$opt" "$selected"                                        
                else
                    INDEX=$(( $LINE_OFFSET / $HEIGHT ))
                    print_option "$opt" "$INDEX"                                              
                fi
                (( LINE_OFFSET = LINE_OFFSET + $HEIGHT  ))                                    
            done

            case `key_input` in                                                               
                enter) break;;                                                                

                up)    ((selected = selected - 1)); 
                    if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;                   

                down)  ((selected = selected + 1));                                           
                    if [ $selected -ge $# ]; then selected=0; fi;;    

                left) 
                    $PREVIOUS_STEP
                    ;;    

                right) 
                    exit 0
                    ;;  

            esac

    done

    cursor_to $lastrow                                                                        
    printf "\n"
    cursor_blink_on

    return $selected
}



function parse_json()
{

    throw() {
        echo "$*" >&2
        exit 1
    }

    BRIEF=0
    LEAFONLY=0
    PRUNE=0
    NO_HEAD=0
    NORMALIZE_SOLIDUS=0

    parse_options() {

        set -- "$@"
        local ARGN=$#
        while [ "$ARGN" -ne 0 ]
        do
        case $1 in
            -b) BRIEF=1
                LEAFONLY=1
                PRUNE=1
            ;;
            -l) LEAFONLY=1
            ;;
            -p) PRUNE=1
            ;;
            -n) NO_HEAD=1
            ;;
            -s) NORMALIZE_SOLIDUS=1
            ;;
            ?*) echo "ERROR: Unknown option."
                exit 0
            ;;
        esac
        shift 1
        ARGN=$((ARGN-1))
        done
    }

    awk_egrep () {
        local pattern_string=$1

        gawk '{
        while ($0) {
            start=match($0, pattern);
            token=substr($0, start, RLENGTH);
            print token;
            $0=substr($0, start+RLENGTH);
        }
        }' pattern="$pattern_string"
    }

    tokenize () {
        local GREP
        local ESCAPE
        local CHAR

        if echo "test string" | egrep -ao --color=never "test" >/dev/null 2>&1
        then
        GREP='egrep -ao --color=never'
        else
        GREP='egrep -ao'
        fi

        if echo "test string" | egrep -o "test" >/dev/null 2>&1
        then
        ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
        CHAR='[^[:cntrl:]"\\]'
        else
        GREP=awk_egrep
        ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
        CHAR='[^[:cntrl:]"\\\\]'
        fi

        local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
        local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
        local KEYWORD='null|false|true'
        local SPACE='[[:space:]]+'

        local is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
        if [ $is_wordsplit_disabled != 0 ]; then setopt shwordsplit; fi
        $GREP "$STRING|$NUMBER|$KEYWORD|$SPACE|." | egrep -v "^$SPACE$"
        if [ $is_wordsplit_disabled != 0 ]; then unsetopt shwordsplit; fi
    }

    parse_array () {
        local index=0
        local ary=''
        read -r token
        case "$token" in
        ']') ;;
        *)
            while :
            do
            parse_value "$1" "$index"
            index=$((index+1))
            ary="$ary""$value" 
            read -r token
            case "$token" in
                ']') break ;;
                ',') ary="$ary," ;;
                *) throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
            esac
            read -r token
            done
            ;;
        esac
        [ "$BRIEF" -eq 0 ] && value=$(printf '[%s]' "$ary") || value=
        :
    }

    parse_object () {
        local key
        local obj=''
        read -r token
        case "$token" in
        '}') ;;
        *)
            while :
            do
            case "$token" in
                '"'*'"') key=$token ;;
                *) throw "EXPECTED string GOT ${token:-EOF}" ;;
            esac
            read -r token
            case "$token" in
                ':') ;;
                *) throw "EXPECTED : GOT ${token:-EOF}" ;;
            esac
            read -r token
            parse_value "$1" "$key"
            obj="$obj$key:$value"        
            read -r token
            case "$token" in
                '}') break ;;
                ',') obj="$obj," ;;
                *) throw "EXPECTED , or } GOT ${token:-EOF}" ;;
            esac
            read -r token
            done
        ;;
        esac
        [ "$BRIEF" -eq 0 ] && value=$(printf '{%s}' "$obj") || value=
        :
    }

    parse_value () {
        local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
        case "$token" in
        '{') parse_object "$jpath" ;;
        '[') parse_array  "$jpath" ;;
        ''|[!0-9]) throw "EXPECTED value GOT ${token:-EOF}" ;;
        *) value=$token
            [ "$NORMALIZE_SOLIDUS" -eq 1 ] && value=$(echo "$value" | sed 's#\\/#/#g')
            isleaf=1
            [ "$value" = '""' ] && isempty=1
            ;;
        esac
        [ "$value" = '' ] && return
        [ "$NO_HEAD" -eq 1 ] && [ -z "$jpath" ] && return

        [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 0 ] && print=1
        [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && [ $PRUNE -eq 0 ] && print=1
        [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 1 ] && [ "$isempty" -eq 0 ] && print=1
        [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && \
        [ $PRUNE -eq 1 ] && [ $isempty -eq 0 ] && print=1
        [ "$print" -eq 1 ] && printf "[%s]\t%s\n" "$jpath" "$value"
        :
    }

    parse () {
        read -r token
        parse_value
        read -r token
        case "$token" in
        '') ;;
        *) throw "EXPECTED EOF GOT $token" ;;
        esac
    }

        parse_options "$@"
        tokenize | parse

}


function menu(){

    CONFIG_FILE=$1
    JSON_PARSED=$(echo $MENU | parse_json -l)
    JSON_SELECT_LENGTH=$(getarrlen select.options)
    HEADING=$(getkey select.heading)
    CLEAR_SCREEN=$(getkey select.clear)
    CLEAR_BEFORE_COMMAND_SCREEN=$(getkey select.clear_before_command)
    declare SELECT_ARRAY_SIDEBAR_ICON=$(getkey select.icon)
    HIDE_MESSAGE=$(getkey select.hide_message)
    DISPLAY_HELP=$(getkey select.display_help)
    RESET_LOOP=$(getkey select.reset_loop)
    PREVIOUS_STEP=$(getkey select.previous_step)

    if $CLEAR_SCREEN; then clear; fi

    SELECT_ARRAY=()
    for (( LOOP=0; LOOP<${JSON_SELECT_LENGTH}; LOOP++ ))
    do 

        declare LOOP_SELECT_INDEX=$LOOP
        declare LOOP_SELECT_TITLE=$(getkey select.options[$LOOP].title)
        declare LOOP_SELECT_TITLE_STYLE=$(getkey select.options[$LOOP].title_style)
        declare LOOP_SELECT_DESCRIPTION=$(getkey select.options[$LOOP].description)
        declare LOOP_SELECT_DESCRIPTION_STYLE=$(getkey select.options[$LOOP].description_style)
        declare LOOP_SELECT_COMMAND=$(getkey select.options[$LOOP].command)
        declare LOOP_SELECT_HEIGHT=$(getkey select.options[$LOOP].height)
        declare LOOP_SELECT_SIDEBAR_STYLE=$(getkey select.options[$LOOP].bullet)

        LOOP_SELECT_COMMAND=${LOOP_SELECT_COMMAND//\\/}  

        TITLE_STYLE_TEXT_COLOUR="${TEXT_GRAY_100}"
        DESCRIPTION_STYLE_TEXT_COLOUR="${TEXT_GRAY_400}"
        SIDELINE_STYLE_BORDER_COLOUR="${BORDER_GRAY_900}"

        parse_classes "TITLE_STYLE" "${LOOP_SELECT_TITLE_STYLE}"
        parse_classes "DESCRIPTION_STYLE" "${LOOP_SELECT_DESCRIPTION_STYLE}"

        SELECT_ARRAY+=("")

        declare SELECT_ARRAY_INDEX_$LOOP="${LOOP_SELECT_INDEX}"
        declare SELECT_ARRAY_TITLE_$LOOP="${LOOP_SELECT_TITLE}"
        declare SELECT_ARRAY_TITLE_STYLE_$LOOP="${LOOP_SELECT_TITLE_STYLE}"
        declare SELECT_ARRAY_DESCRIPTION_$LOOP="${LOOP_SELECT_DESCRIPTION}"
        declare SELECT_ARRAY_DESCRIPTION_STYLE_$LOOP="${LOOP_SELECT_DESCRIPTION_STYLE}"
        declare SELECT_ARRAY_COMMAND_$LOOP="${LOOP_SELECT_COMMAND}"
        declare SELECT_ARRAY_HEIGHT_$LOOP="${LOOP_SELECT_HEIGHT}"
        declare SELECT_ARRAY_SIDEBAR_STYLE_$LOOP="${LOOP_SELECT_SIDEBAR_STYLE}"

    done

    if $DISPLAY_HELP; then
        printf "$TEXT_STONE_500 $ICON_ARROW_W $TEXT_STONE_600 menu $TEXT_WHITE_FFF $ICON_CIRCLE $TEXT_STONE_500 $ICON_ARROW_N $TEXT_STONE_600 up $TEXT_WHITE_FFF $ICON_CIRCLE $TEXT_STONE_500 $ICON_ARROW_S $TEXT_STONE_600 down $TEXT_WHITE_FFF $ICON_CIRCLE $TEXT_STONE_500 $ICON_ARROW_E $TEXT_STONE_600 exit $TEXT_WHITE_FFF $ICON_CIRCLE $TEXT_STONE_500 enter$TEXT_STONE_600 choose $RESET_TEXT\n\n";
    fi

    printf "$HEADING\n\n"
    select_option "${SELECT_ARRAY[@]}"
    choice=$?

    COMMAND_NAME="SELECT_ARRAY_COMMAND_$choice"
    COMMAND="${!COMMAND_NAME}"

    if ! $HIDE_MESSAGE; then
        printf '%s' "Running command:${TEXT_EMERALD_300} ${COMMAND} ${RESET_TEXT}"
    fi

    if $CLEAR_BEFORE_COMMAND_SCREEN; then clear; fi
    eval "${COMMAND}"

    if $RESET_LOOP; then
        options $@
    fi

}


# ╭──────────────────────────────────────────────────────────────────────────────╮
# │                                   SPINNER                                    │
# ╰──────────────────────────────────────────────────────────────────────────────╯
function spin()
{
    tput civis

    # Clear Line
    CL="\e[2K"
    # Spinner Character
    SPINNER="𛰀𛱃𛱄𛱅○𛱅𛱄𛱃𛰀"

    function spinner() {
        TASK=$1
        MESSAGE=$2
        while :; do
            jobs %1 > /dev/null 2>&1 
            [ $? = 0 ] || {
                printf "${TEXT_EMERALD_500}${ICON_TICK}${RESET_ALL} ${TASK} ${TEXT_EMERALD_500}Done${RESET_ALL}\n"
                break
            }

            if [ $? -ne 0 ]; then
                printf "${TEXT_RED_500}${ICON_CROSS}${RESET_ALL} ${TASK} ${TEXT_RED_500}Failed${RESET_ALL}\n"
                break
            fi

            for (( i=0; i<${#SPINNER}; i++ )); do
                sleep 0.05
                printf "${TEXT_AMBER_500}${SPINNER:$i:1}${RESET_ALL} ${TASK} ${TEXT_AMBER_500}${MESSAGE}${RESET_ALL}\r"
            done
        done
    }

    MESSAGE="${2-InProgress}"
    TASK="${3-$1}"

    if [[ ! -z "${4}" ]]; then
        SPINNER=$(echo -n "${4//[[:space:]]/}")
    fi

    if [[ ! -z "${5}" ]]; then
        $1 > /dev/null 2>&1 & spinner "$TASK" "$MESSAGE"
    else
        $1 & spinner "$TASK" "$MESSAGE"
    fi

    tput cnorm
}


# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                              ║
# ║                                MENU FUNCTIONS                                ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

function mainmenu()
{
    
    MENU='
        {
        "select": {
            "heading": "'${TEXT_YELLOW_500}'Select the task to perform.",
            "clear": true,
            "clear_before_command": true,
            "icon": "ICON_FADE_200",
            "hide_message": true,
            "display_help": true,
            "reset_loop": false,
            "previous_step": "exit",
            "options": [
                {
                    "title": "Save ⏩ to container registry",
                    "title_style": "",
                    "description": "Backup docker website code, assets and database.",
                    "description_style": "TEXT_GRAY_500",
                    "command": "cmd_export_registry; push_to_registry; exit",
                    "bullet": "BORDER_SKY_400"
                },
                {
                    "title": "Load ⏪ from container registry",
                    "title_style": "",
                    "description": "Recover docker website code, assets and database.",
                    "description_style": "TEXT_GRAY_500",
                    "command": "cmd_import_registry; exit",
                    "bullet": "BORDER_EMERALD_400"
                }
            ]
        }
    }'
    menu "$MENU"

}


# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                              ║
# ║                            MAIN EXPORT FUNCTIONS                             ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝


# ╭──────────────────────────────────────────────────────────╮
# │                   EXPORT TO REGISTRY                     │
# ╰──────────────────────────────────────────────────────────╯
function cmd_export_registry() {
    clear

    if [ -z ${VUMP_WEBSITE_VOLUME_NAME+x} ]; then 
        select_volume "Select WEBSITE volume to export data from [.env VUMP_WEBSITE_VOLUME_NAME]"
        VUMP_WEBSITE_VOLUME_NAME="$VOLUME"
    fi

    if [ -z ${VUMP_DATABASE_CONTAINER_NAME+x} ]; then 
        select_container "Select DATABASE container to export data from [.env VUMP_DATABASE_CONTAINER_NAME]"
        VUMP_DATABASE_CONTAINER_NAME="$CONTAINER"
    fi

    if [ -z ${VUMP_DB_USERNAME+x} ]; then 
        ask_question "database username?  [.env VUMP_DB_USERNAME]"
        VUMP_DB_USERNAME="$ANSWER"
    fi

    if [ -z ${VUMP_DB_PASSWORD+x} ]; then
        ask_question "$VUMP_DB_USERNAME database password? [.env VUMP_DB_PASSWORD]"
        VUMP_DB_PASSWORD="$ANSWER"
    fi

    if [ -z ${VUMP_DB_DATABASE+x} ]; then
        select_database "Select database to backup. [.env VUMP_DB_DATABASE]"
        VUMP_DB_DATABASE="$VUMP_DB_DATABASE"
    fi

    if [ -z ${VUMP_IMAGE_NAME+x} ]; then 
        ask_question "Name of container image to export to? [.env VUMP_IMAGE_NAME]"
        VUMP_IMAGE_NAME="$ANSWER"
    fi

    if [ -z ${VUMP_REGISTRY_REPO+x} ]; then 
        ask_question "Container registry to export to? [.env VUMP_REGISTRY_REPO]"
        VUMP_REGISTRY_REPO="$ANSWER"
    fi


    printf "The website data from '${VUMP_WEBSITE_VOLUME_NAME}' will be in /volume-data/\n"
    printf "The database data from '${VUMP_DATABASE_CONTAINER_NAME}' will be in /db-data/\n\n"
    confirmation "You are going to export '${VUMP_WEBSITE_VOLUME_NAME}' and '${VUMP_DATABASE_CONTAINER_NAME}' to registry ${VUMP_REGISTRY_REPO}"
    spin "cmd_run_export_registry" "Exporting" "export_registry" 

}


function cmd_run_export_registry()
{

    # ╭──────────────────────────────────────────────────────────╮
    # │                         DATABASE                         │
    # ╰──────────────────────────────────────────────────────────╯

    vump --dbfile --container $VUMP_DATABASE_CONTAINER_NAME --database $VUMP_DB_DATABASE --username $VUMP_DB_USERNAME --password $VUMP_DB_PASSWORD --filename backup.sql

    # ╭──────────────────────────────────────────────────────────╮
    # │                         WEBSITE                          │
    # ╰──────────────────────────────────────────────────────────╯

    vump --save --volume $VUMP_WEBSITE_VOLUME_NAME --image $VUMP_IMAGE_NAME

    # ╭──────────────────────────────────────────────────────────╮
    # │                    COPY DB INTO IMAGE                    │
    # ╰──────────────────────────────────────────────────────────╯
    if ! docker run\
        -v "$PWD":/mount-pwd \
        $VUMP_IMAGE_NAME \
        /bin/sh -c "mkdir -p /db-data/ && cp -p /mount-pwd/backup.sql /db-data/backup.sql";
    then
        echo "Error: Failed to copy DB into container"
        exit 1
    fi

    CONTAINER_ID=$(docker ps -lq)

    docker commit -m "Saving website container" "$CONTAINER_ID" "$VUMP_IMAGE_NAME"

    docker container rm "$CONTAINER_ID"

    # ╭──────────────────────────────────────────────────────────╮
    # │                    EXPORT TO REGISTRY                    │
    # ╰──────────────────────────────────────────────────────────╯
    
}



# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                                                                              ║
# ║                            MAIN IMPORT FUNCTIONS                             ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝


# ╭──────────────────────────────────────────────────────────╮
# │                   IMPORT TO REGISTRY                     │
# ╰──────────────────────────────────────────────────────────╯
function cmd_import_registry() {
    clear

    if [ -z ${VUMP_REGISTRY_REPO+x} ]; then 
        ask_question "Container registry to import from? [.env VUMP_REGISTRY_REPO]"
        VUMP_REGISTRY_REPO="$ANSWER"
    fi

    if [ -z ${VUMP_PULL_TAG+x} ]; then 
        ask_question "Which image :tag to pull? [.env VUMP_PULL_TAG]"
        VUMP_PULL_TAG="$ANSWER"
    fi

    if [ -z ${VUMP_WEBSITE_VOLUME_NAME+x} ]; then 
        select_volume "Select WEBSITE volume to export data from [.env VUMP_WEBSITE_VOLUME_NAME]"
        VUMP_WEBSITE_VOLUME_NAME="$VOLUME"
    fi

    if [ -z ${VUMP_DATABASE_CONTAINER_NAME+x} ]; then 
        select_container "Select DATABASE container to export data from [.env VUMP_DATABASE_CONTAINER_NAME]"
        VUMP_DATABASE_CONTAINER_NAME="$CONTAINER"
    fi

    if [ -z ${VUMP_DB_USERNAME+x} ]; then 
        ask_question "database username?  [.env VUMP_DB_USERNAME]"
        VUMP_DB_USERNAME="$ANSWER"
    fi

    if [ -z ${VUMP_DB_PASSWORD+x} ]; then
        ask_question "$VUMP_DB_USERNAME database password? [.env VUMP_DB_PASSWORD]"
        VUMP_DB_PASSWORD="$ANSWER"
    fi

    if [ -z ${VUMP_DB_DATABASE+x} ]; then
        select_database "Select database to backup. [.env VUMP_DB_DATABASE]"
        VUMP_DB_DATABASE="$VUMP_DB_DATABASE"
    fi

    printf "The website data in /volume-data/ will be put into the '${VUMP_WEBSITE_VOLUME_NAME}' volume.\n"
    printf "The database data in /db-data/ will be loaded into the '${VUMP_DATABASE_CONTAINER_NAME}' container.\n\n"
    confirmation "Website backup from '${VUMP_REGISTRY_REPO}' will be loaded into '${VUMP_DATABASE_CONTAINER_NAME}' DB container and ${VUMP_WEBSITE_VOLUME_NAME} website volume."
    
    cmd_run_import_registry

}

function cmd_run_import_registry()
{
    pull_from_registry

    vump --load --image $VUMP_REGISTRY_REPO:$VUMP_PULL_TAG --volume $VUMP_WEBSITE_VOLUME_NAME

    vump --dbload --image $VUMP_REGISTRY_REPO:$VUMP_PULL_TAG --container $VUMP_DATABASE_CONTAINER_NAME --database $VUMP_DB_DATABASE --username $VUMP_DB_USERNAME --password $VUMP_DB_PASSWORD
    
    rm ./backup.sql
}


stylesheet
mainmenu